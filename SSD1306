import time
from i2cpy import I2C
from PIL import Image, ImageDraw, ImageFont
import os


# CH341Aを介してI2Cバスを初期化
i2c = I2C(driver="ch341") # 実際の環境に合わせてください

# SSD1306のI2Cアドレス
SSD1306_ADDR = 0x3C

# SSD1306コマンド定義
SSD1306_COMMAND = 0x00  # コマンド送信用
SSD1306_DATA = 0x40     # データ送信用

# ディスプレイのサイズ
WIDTH = 128
HEIGHT = 64

# SSD1306初期化コマンド (Adafruitスタイルに基づく)
INIT_COMMANDS = [
    0xAE,         # ディスプレイOFF
    0xD5, 0x80,   # クロック設定
    0xA8, HEIGHT - 1, # マルチプレックス比
    0xD3, 0x00,   # ディスプレイオフセット
    0x40,         # スタートライン設定
    0x8D, 0x14,   # チャージポンプ設定 (0x10 for external VCC)
    0xA1,         # セグメントリマップ (0xA0 or 0xA1)
    0xC8,         # COM出力スキャン方向 (0xC0 or 0xC8)
    0xDA, 0x12 if HEIGHT == 64 else 0x02, # COMピン設定
    0x81, 0xCF,   # コントラスト設定
    0xD9, 0xF1,   # プリチャージ期間 (0x22 for external VCC)
    0xDB, 0x40,   # VCOMH設定
    0xA4,         # 全体表示ON/OFF (0xA4: RAM content, 0xA5: All ON)
    0xA6,         # ノーマル/インバース表示 (0xA6: Normal, 0xA7: Inverse)
    0xAF          # ディスプレイON
]

def send_command(cmd):
    """単一コマンドを送信"""
    try:
        buffer = bytes([SSD1306_COMMAND, cmd])
        i2c.writeto(SSD1306_ADDR, buffer)
        return True
    except Exception as e:
        print(f"コマンド送信エラー: {cmd:#02x}, エラー: {e}")
        return False

def send_command_array(cmd_array):
    """複数コマンドを送信"""
    try:
        for cmd in cmd_array:
            if not send_command(cmd): # 個々のコマンド送信結果を確認
                return False
        return True
    except Exception as e:
        print("コマンド配列送信エラー:", e)
        return False

def send_data(data):
    """データ（ピクセル情報）を送信"""
    try:
        # SSD1306のデータ送信は通常、コントロールバイトの後に連続したデータバイトを送る
        # i2cpyのwritetoがリストのリストや連続したバッファをどう扱うかによるが、
        # 一般的にはコントロールバイトとデータペイロードを結合して一度に送信する。
        if not data:
            return True # 送信するデータがない場合は成功とする
        buffer = bytes([SSD1306_DATA]) + data
        i2c.writeto(SSD1306_ADDR, buffer)
        return True
    except Exception as e:
        print("データ送信エラー:", e)
        return False

def init_display():
    """ディスプレイを初期化"""
    print("ディスプレイ初期化中...")
    if send_command_array(INIT_COMMANDS):
        time.sleep(0.1)  # 初期化待機
        print("初期化完了")
        return True
    else:
        print("初期化失敗")
        return False


def clear_display():
    """ディスプレイをクリア (全ピクセルをOFF)"""
    send_command(0x20)  # アドレッシングモード設定
    send_command(0x00)  # 水平アドレッシングモード
    send_command(0x21)  # カラムアドレス設定
    send_command(0)     # スタートカラム 0
    send_command(WIDTH - 1) # エンドカラム WIDTH-1
    send_command(0x22)  # ページアドレス設定
    send_command(0)     # スタートページ 0
    send_command((HEIGHT // 8) - 1) # エンドページ (HEIGHT/8)-1
    
    # すべてのピクセルをOFFにするデータ送信
    # 1ページあたりWIDTHバイト、合計 (HEIGHT/8) ページ
    # WIDTH * (HEIGHT // 8) バイトの0x00を送信
    chunk_size = 16 # 一度に送信するデータの最大サイズ (I2Cバッファサイズに依存する場合がある)
    num_bytes_to_clear = WIDTH * (HEIGHT // 8)
    data_chunk = bytes([0x00] * chunk_size)
    
    for i in range(0, num_bytes_to_clear, chunk_size):
        actual_chunk_size = min(chunk_size, num_bytes_to_clear - i)
        if actual_chunk_size < chunk_size:
            data_to_send = bytes([0x00] * actual_chunk_size)
        else:
            data_to_send = data_chunk
        if not send_data(data_to_send):
            print("ディスプレイクリア中のデータ送信エラー")
            return False
    return True

def image_to_ssd1306_bytes_horizontal_mode(image):
    """
    Pillowの1bit画像をSSD1306用バイト列に変換 (水平アドレッシングモード用)。
    データはページごと、各ページ内でカラムごとに並ぶ。
    各バイトのLSBがページの上部ピクセル、MSBが下部ピクセルに対応。
    """
    width, height = image.size
    # height は8の倍数であることを前提とする (display_textで調整済み)
    # assert height % 8 == 0, "画像の高さは8の倍数である必要があります"
    
    pixels = image.load() # ピクセルアクセス用オブジェクト
    byte_data = bytearray()
    
    num_pages = height // 8
    
    for page_y in range(num_pages):  # ページインデックス (0 から num_pages-1)
        for x in range(width):       # カラムインデックス (0 から width-1)
            byte_val = 0
            for bit_in_page in range(8): # ページ内のビット (0=LSB=上, 7=MSB=下)
                # ピクセルY座標を計算
                pixel_y_coord = page_y * 8 + bit_in_page
                
                # 画像の範囲内か確認 (通常は padded_height なので範囲内のはず)
                if pixel_y_coord < height:
                    if pixels[x, pixel_y_coord] != 0:  # ピクセルがON (白) の場合
                        byte_val |= (1 << bit_in_page)
            byte_data.append(byte_val)
            
    return byte_data

def display_text(text, x_start_disp, y_start_disp, color=1, font_path="C:\\Windows\\Fonts\\arial.ttf", font_size=12):
    """
    指定された位置にテキストを表示します。
    x_start_disp, y_start_disp: 表示を開始するディスプレイ上のピクセル座標。
    """
    if not os.path.exists(font_path):
        print(f"フォントファイルが見つかりません: {font_path}")
        # デフォルトフォントを試みるか、エラーを出す
        try:
            font = ImageFont.load_default() # Pillowのデフォルトフォント
            print("デフォルトフォントを使用します。")
        except IOError:
            print("デフォルトフォントもロードできませんでした。テキスト表示をスキップします。")
            return
    else:
        try:
            font = ImageFont.truetype(font_path, font_size)
        except IOError:
            print(f"フォント {font_path} のロードに失敗しました。デフォルトフォントを試みます。")
            try:
                font = ImageFont.load_default()
                print("デフォルトフォントを使用します。")
            except IOError:
                print("デフォルトフォントもロードできませんでした。テキスト表示をスキップします。")
                return

    # 1. 文字のバウンディングボックスを取得
    bbox = font.getbbox(text)
    # bbox は (left, top, right, bottom)
    # left, top はフォント原点からのオフセット。文字の実際の左上隅ではない場合がある。
    text_x_offset_in_font = bbox[0]
    text_y_offset_in_font = bbox[1]
    char_actual_width = bbox[2] - bbox[0]
    char_actual_height = bbox[3] - bbox[1]

    if char_actual_width <= 0 or char_actual_height <= 0:
        # print(f"警告: テキスト「{text}」の描画サイズが0以下です。スキップします。")
        return # 空白文字などの場合

    # 2. Pillowイメージを作成し、文字を正確に描画
    # イメージサイズは文字の実際の幅と高さ
    # 文字の (text_x_offset_in_font, text_y_offset_in_font) がイメージの (0,0) に来るように描画
    img_char_content = Image.new('1', (char_actual_width, char_actual_height), 0) # 背景黒
    draw = ImageDraw.Draw(img_char_content)
    # 描画アンカーを (0,0) に設定し、bboxの左上オフセットを引くことで、
    # 文字のバウンディングボックスの左上がイメージの(0,0)に来るようにする
    draw.text((-text_x_offset_in_font, -text_y_offset_in_font), text, font=font, fill=1 if color else 0)

    # 3. イメージの高さを8の倍数にパディング (下方向)
    padded_height = ((char_actual_height + 7) // 8) * 8
    
    if padded_height == img_char_content.height:
        img_to_convert = img_char_content
    else:
        img_to_convert = Image.new('1', (char_actual_width, padded_height), 0) # 黒でパディング
        img_to_convert.paste(img_char_content, (0,0)) # 元の画像を左上に配置
    
    # デバッグ用: Pillowイメージをファイルに保存して確認
    # img_to_convert.save(f"debug_text_{text.replace(' ', '_')}_{font_size}pt.png")

    # 4. SSD1306用バイト列に変換
    ssd1306_data = image_to_ssd1306_bytes_horizontal_mode(img_to_convert)

    # 5. ディスプレイのアドレッシングと表示範囲を設定
    # x_start_disp, y_start_disp はピクセル単位。
    # 表示するカラム範囲
    col_start = max(0, x_start_disp)
    col_end = min(WIDTH - 1, x_start_disp + char_actual_width - 1)
    if col_start > col_end: # 表示幅がない (完全に画面外か、幅がマイナス)
        return

    # 表示するページ範囲
    # y_start_disp のピクセルが含まれるページが開始ページ
    page_start = max(0, y_start_disp // 8)
    # img_to_convert の最終ピクセル (y = y_start_disp + padded_height - 1) が含まれるページが終了ページ
    page_end = min((HEIGHT // 8) - 1, (y_start_disp + padded_height - 1) // 8)
    if page_start > page_end: # 表示ページがない
        return

    send_command(0x20)  # メモリアドレッシングモード設定
    send_command(0x00)  # 水平アドレッシングモード

    send_command(0x21)  # カラムアドレス設定
    send_command(col_start)
    send_command(col_end)

    send_command(0x22)  # ページアドレス設定
    send_command(page_start)
    send_command(page_end)

    # 6. データを送信
    # 送信するデータは、ssd1306_data から、画面に実際に表示される部分を切り出す
    final_data_to_send = bytearray()
    
    # 表示される実際の幅 (ピクセル数 = カラム数)
    actual_display_width_on_screen = col_end - col_start + 1
    # 表示される実際のページ数
    actual_display_num_pages_on_screen = page_end - page_start + 1

    for p_idx_on_screen in range(actual_display_num_pages_on_screen):
        # この画面表示ページ (p_idx_on_screen) が、元の文字画像 (img_to_convert) のどのページに対応するか
        # page_start は画面上の開始ページ、y_start_disp//8 も画面上の開始ページ(クリップ前)
        source_page_idx_in_char_image = (page_start + p_idx_on_screen) - (y_start_disp // 8)
        
        if not (0 <= source_page_idx_in_char_image < (padded_height // 8)):
            # この画面ページは、元文字画像の上または下にはみ出ているので、データは送らない
            # (またはダミーデータ0x00を送る。ここではスキップ、または黒で埋めるなら0x00*actual_display_width_on_screen)
            # 通常は page_start, page_end の計算でこのケースはフィルタリングされるはず
            # もしフィルタリングしきれない場合は、安全のため黒データを送る
            # final_data_to_send.extend(bytes([0x00] * actual_display_width_on_screen))
            continue

        # 元の文字画像のこのページのデータの先頭インデックス (ssd1306_data内)
        offset_to_page_in_source_data = source_page_idx_in_char_image * char_actual_width
        
        # このページで、元の文字画像データのどのカラムから読み始めるか
        # col_start は画面上の開始カラム、x_start_disp も画面上の開始カラム(クリップ前)
        source_col_start_in_char_image = col_start - x_start_disp
        
        # 読み取り開始位置と終了位置 (ssd1306_data内のインデックス)
        read_start_idx = offset_to_page_in_source_data + max(0, source_col_start_in_char_image)
        read_end_idx = offset_to_page_in_source_data + max(0, source_col_start_in_char_image) + actual_display_width_on_screen
        
        # スライスする際に、元の文字データの幅 (char_actual_width) を超えないように調整
        # また、source_col_start_in_char_image が負の場合 (文字が画面左にはみ出る) は、
        # 元データの0列目から読むことになる。
        
        # 元の文字データから、実際に画面に表示される部分をスライス
        # 各ページについて、(char_actual_width) バイトの中から (actual_display_width_on_screen) バイトを取り出す
        # 取り出し開始オフセットは (max(0, col_start - x_start_disp))
        
        slice_start_offset_in_page_data = max(0, col_start - x_start_disp)
        slice_end_offset_in_page_data = slice_start_offset_in_page_data + actual_display_width_on_screen

        # スライス範囲が元データの幅を超えないようにする
        slice_end_offset_in_page_data = min(slice_end_offset_in_page_data, char_actual_width)
        
        # 元のssd1306_dataの該当ページからスライス
        start_index_for_slice = offset_to_page_in_source_data + slice_start_offset_in_page_data
        end_index_for_slice = offset_to_page_in_source_data + slice_end_offset_in_page_data
        
        bytes_for_this_page_on_screen = ssd1306_data[start_index_for_slice : end_index_for_slice]
        
        # スライス結果が actual_display_width_on_screen より短い場合 (文字の右端が画面内で終わる場合など)
        # 足りない分は0で埋めるべきか？ SSD1306は期待したバイト数を受信する。
        # ここでは、スライスされたバイト数だけを送る。SSD1306は次のデータで残りを埋めるか、次の行に移る。
        # 水平アドレッシングモードでは、カラムが終端に達すると次のページに行く。
        # なので、(col_end - col_start + 1) バイトをきっちり送る必要がある。
        
        if len(bytes_for_this_page_on_screen) < actual_display_width_on_screen:
            # 文字の右側が画面の表示領域 (col_end) より手前で終わる場合
            # または、文字の左側が画面の表示領域 (col_start) より右で始まる場合
            # 足りない分を0でパディングする（特に文字が画面表示領域より小さい場合）
            padding_needed = actual_display_width_on_screen - len(bytes_for_this_page_on_screen)
            if source_col_start_in_char_image > 0: # 文字の左側に空白が必要な場合
                bytes_for_this_page_on_screen = bytes([0x00] * min(padding_needed, source_col_start_in_char_image)) + bytes_for_this_page_on_screen
                padding_needed = actual_display_width_on_screen - len(bytes_for_this_page_on_screen) # 残りのパディング
            if padding_needed > 0: # 文字の右側に空白が必要な場合
                 bytes_for_this_page_on_screen += bytes([0x00] * padding_needed)
        
        final_data_to_send.extend(bytes_for_this_page_on_screen)

    if not send_data(final_data_to_send):
        print(f"テキスト「{text}」のデータ送信に失敗しました。")


# --- メイン処理 ---
if __name__ == "__main__":
    try:
        if not init_display():
            exit()
        
        if not clear_display():
            exit()
        print("ディスプレイクリア完了")

        # フォントサイズ12でテキストを表示
        display_text("Hello", 0, 0, font_size=12)
        time.sleep(1) # 確認用ウェイト

        # フォントサイズ16でテキストを表示
        display_text("World", 0, 16, font_size=16) # y=16は3ページ目 (インデックス2) の先頭
        time.sleep(1)

        display_text("Test 123", 5, 35, font_size=10)
        time.sleep(1)
        
        display_text("ディスプレイ", 0, 50, font_size=12, font_path="C:\\Windows\\Fonts\\msgothic.ttc") # 日本語フォントの例


    except Exception as e:
        print("エラー発生:", e)
        import traceback
        traceback.print_exc()
